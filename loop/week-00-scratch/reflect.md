# Reflect — Week 01: Scratch, Control Logic, Abstraction

## 1. What clicked?

- Visual programming (Scratch) can serve as a mental sandbox to prototype logic without syntax overhead.
- Each CS primitive (loop, condition, variable, event) maps cleanly to real-world logic structures.
- Abstraction isn’t just to avoid repetition — it’s to represent intent clearly and reduce cognitive noise.
- Structure > syntax. Looping, branching, and state are universal patterns across languages.

## 2. What was hard?

- Low emotional engagement due to the perceived simplicity of the tool.
- Friction with creating logic that was both “constraint-satisfying” and “meaningful”.
- Slight disconnect between checklist thinking (to pass) vs. system design thinking (to build clarity).

## 3. What would you do differently?

- Start by defining system behavior _before_ jumping into Scratch blocks.
- Use block labels and comments more intentionally to externalize thought flow.
- Treat the `.sb3` file as a traceable artifact from day 1, not just a submission object.

## 4. 🏛 Meta-level feedback

- **Protocol friction:** Low. PACER gave structure to what would otherwise feel like a throwaway assignment.
- **System effectiveness:** High. Mapping constraints to insight surfaced gaps in understanding that wouldn’t be visible without a claim-reflect structure.
- **Tooling:** Manual loop tracking worked, but automation of `check50` result capture and loop templating would scale this better.

## 5. Spillover

- This pattern of building → claim → reflect → mindstamp is portable to other learning areas: C, Python, writing, even decision-making frameworks.
- “Start with system behavior, not syntax” is becoming a default mental move.

## 6. Quote

> "Code can be messy and still work. Logic can’t."

---

> _Powered by Second Mind OS_
